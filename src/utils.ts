import { existsSync, readdirSync, statSync } from "fs";
import { join, parse } from "path";

const NEXTJS_NON_ROUTABLE = ["/_app", "/_document", "/_error", "/middleware"];
const DYNAMIC_SEGMENT_RE = /\[(.*?)\]/g;

// istanbul ignore next: io mocking not worthwhile
export function getPagesDirectory(): string | undefined {
  const dirs = ["pages", join("src", "pages")];
  for (const dir of dirs) {
    if (existsSync(dir)) {
      return dir;
    }
  }
}

// istanbul ignore next: io mocking not worthwhile
export function findFiles(entry: string): string[] {
  return readdirSync(entry).flatMap((file) => {
    const filepath = join(entry, file);
    if (
      statSync(filepath).isDirectory() &&
      !filepath.includes("node_modules")
    ) {
      return findFiles(filepath);
    }
    return filepath;
  });
}

type QueryType = "dynamic" | "catch-all" | "optional-catch-all";

interface Route {
  pathname: string;
  query: Record<string, QueryType>;
}

function convertWindowsPathToUnix(file: string): string {
  return file.replace(/\\/g, "/");
}

export function nextRoutes(files: string[], pagesDirectory: string): Route[] {
  const filenames = files
    .map((file) => file.replace(pagesDirectory, ""))
    .map((file) => file.replace(parse(file).ext, ""))
    .map(convertWindowsPathToUnix)
    .filter((file) => !NEXTJS_NON_ROUTABLE.includes(file));

  return filenames.map((filename) => {
    const segments = filename.match(DYNAMIC_SEGMENT_RE) ?? [];
    const query = segments.reduce<Route["query"]>((acc, cur) => {
      const param = cur
        .replace(/\[/g, "")
        .replace(/\]/g, "")
        .replace("...", "");
      let queryType: QueryType = "dynamic";
      if (cur.startsWith("[[")) {
        queryType = "optional-catch-all";
      } else if (cur.startsWith("[...")) {
        queryType = "catch-all";
      }
      acc[param] = queryType;
      return acc;
    }, {});

    const pathWithoutIndexSuffix = filename.replace(/index$/, "");
    const pathWithoutTrailingSlash =
      pathWithoutIndexSuffix.endsWith("/") && pathWithoutIndexSuffix.length > 2
        ? pathWithoutIndexSuffix.slice(0, -1)
        : pathWithoutIndexSuffix;

    return {
      pathname: pathWithoutTrailingSlash,
      query,
    };
  });
}

function getQueryInterface(
  query: Route["query"]
): [query: string, requiredKeys: number] {
  let requiredKeys = 0;
  const keys = Object.entries(query)
    .map(([key, value]) => {
      switch (value) {
        case "dynamic": {
          requiredKeys += 1;
          return `${key}: string`;
        }
        case "catch-all": {
          requiredKeys += 1;
          return `${key}: string[]`;
        }
        case "optional-catch-all": {
          return `${key}?: string[] | undefined`;
        }
        // istanbul ignore next
        default: {
          const _exhaust: never = value;
          return _exhaust;
        }
      }
    })
    .join("; ");

  return [`{ ${keys} }`, requiredKeys];
}

export function generate(routes: Route[]): string {
  return `\
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Run \`npx nextjs-routes\` to regenerate this file.
/* eslint-disable */

// prettier-ignore
declare module "nextjs-routes" {
  export type Route =
    ${
      !routes.length
        ? "never"
        : `| ${routes
            .map((route) => {
              const [query, requiredKeys] = getQueryInterface(route.query);
              if (requiredKeys > 0) {
                return `{ pathname: "${route.pathname}"; query: Query<${query}> }`;
              } else {
                return `{ pathname: "${route.pathname}"; query?: Query | undefined }`;
              }
            })
            .join("\n    | ")}`
    };

  type Query<Params = {}> = Params & { [key: string]: string | undefined };
}

// prettier-ignore
declare module "next/link" {
  import type { Route } from "nextjs-routes";
  import type { LinkProps as NextLinkProps } from "next/dist/client/link";
  import type { PropsWithChildren, MouseEventHandler } from "react";
  export * from "next/dist/client/link";

  type RouteOrQuery = Route | { query?: { [key: string]: string | undefined } };

  export interface LinkProps extends Omit<NextLinkProps, "href"> {
    href: RouteOrQuery;
  }

  declare function Link(
    props: PropsWithChildren<LinkProps>
  ): DetailedReactHTMLElement<
    {
      onMouseEnter?: MouseEventHandler<Element> | undefined;
      onClick: MouseEventHandler;
      href?: string | undefined;
      ref?: any;
    },
    HTMLElement
  >;

  export default Link;
}

// prettier-ignore
declare module "next/router" {
  import type { Route } from "nextjs-routes";
  import type { NextRouter as Router } from "next/dist/client/router";
  export * from "next/dist/client/router";
  export { default } from "next/dist/client/router";

  type TransitionOptions = Parameters<Router["push"]>[2];

  type Pathname = Route["pathname"];

  type QueryForPathname = {
    [K in Route as K["pathname"]]: Exclude<K["query"], undefined>;
  };

  type RouteOrQuery = Route | { query: { [key: string]: string | undefined } };

  export interface NextRouter<P extends Pathname = Pathname>
    extends Omit<Router, "push" | "replace"> {
    pathname: P;
    route: P;
    query: QueryForPathname[P];
    push(
      url: RouteOrQuery,
      as?: string,
      options?: TransitionOptions
    ): Promise<boolean>;
    replace(
      url: RouteOrQuery,
      as?: string,
      options?: TransitionOptions
    ): Promise<boolean>;
  }

  export function useRouter<P extends Pathname>(): NextRouter<P>;
}
`;
}
